##### http 导致队头堵塞

1.http0.9 不能并行发起 http 请求，导致队头堵塞，http1.1 可以并行，得到缓解

2.长连接，多个请求复用一个 tcp 连接，会导致**TCP 黏包**，HTTP 使用 **Content-Length 首部** 来区分数据长度，另外还有一种方法是使用 **chunked 编码（分块传输编码）**，说白了就是在数据末尾加上一个结束的标识符来进行区分。HTTP/1.1 的解决办法是按顺序发送，并且按顺序返回。比如先发送了 A 请求之后再发送 B 请求，那么服务端一定要先返回 A 请求的数据，即使 B 请求已经处理完了，这样就做到了请求的区分，由此也带来了队头阻塞的问题。

##### tcp 导致队头堵塞

1.应用层（如 HTTP）发送的数据会先传递给传输层（TCP），TCP 收到数据后并不会直接发送，而是先把数据切割成 MSS 大小的包，再按窗口大小将多个包丢给网络层（IP 协议）处理。IP 层的作用是“实现终端节点之间的通信”，并不保证数据的可靠性和有序性，所以接收端可能会先收到窗口末端的数据，这个时候 TCP 是不会向上层应用交付数据的，它得等到前面的数据都接收到了才向上交付，所以这就出现了队头阻塞，即队头的包如果发生延迟或者丢失，队尾必须等待发送端重新发送并接收到数据后才会一起向上交付。

简述：使用 http0.9，第一个 http 请求会堵塞后面的请求（http0.9 同时只能有一个 http 请求），当一个请求处理时间较长，或者 tcp 丢包队头堵塞时影响效率

http1.1 使用长连接，前一个请求也会堵塞后一个请求的返回结果（同一个 tcp 连接，a,b 请求先后发送，b 请求先完成，也会等到 a 请求完成再返回两个结果）

http2.0 解决引入了多路复用（Multiplexing）机制,多个请求可以同时在一个 TCP 连接上进行传输，并且每个请求都有一个独立的流（Stream）标识，不再受到前面请求的影响
