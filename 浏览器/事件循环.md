### 事件循环

> 在浏览器环境中，js 是运行在渲染主线程中的，这意味着它一次只能执行一段代码。
> 然而，Web 应用程序通常需要处理可能需要很长时间才能完成的任务，比如进行网络请求或执行复杂的计算。如果这些任务是同步执行的，它们将阻塞其他代码的执行，使应用程序无法响应。
> 为了解决这个问题，JavaScript 使用了事件循环机制。事件循环不断检查队列中的新任务，并逐个执行它们。当启动一个异步任务，比如一个 AJAX 请求时，它被添加到队列中，事件循环继续运行其他代码。一旦任务完成，与任务相关联的回调函数被推入队列，当它到达队列的前面时，事件循环执行它。

> 通过使用事件循环，JavaScript 可以高效地处理异步任务。


### 事件循环简述

> 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
在Chrome源码中，他开启一个不会结束的for循环，每次循环从消息队列中取出第一个惹怒我执行，而其它线程只需要在合适的时候将任务加入到队列末尾即可。

> 过去把消息队列简单的分为宏队列和微队列，这种说话已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

> 根据W3C官方的解释，每个人物都有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。但是浏览器必须有一个微队列，并且微队列一定具有最高的优先级，必须优先调度执行。

- 渲染主线程

> 解析 html，

> 解析 css ，

> 计算样式（em 换算 px 等），

> 布局，

> 处理图层（z-index 顺序等），

> 每秒画页面 60 次（60fps），

> 执行全局 js 代码，

> 执行事件处理函数，

> 执行计时器的回调等等

渲染主线程要处理这么多任务，如何进行调度？

#### 采用事件循环（也叫消息循环）

> 在最开始的时候 ，渲染主线程会进入一个无限的循环

> 每一次的循环会检查**消息队列**当中是否有任务存在，如果有，就取出第一个任务，执行完一个后进入下一次循环，如果没有，进入休眠状态

> 其他所有线程（包括其他线程的进程）随时可以向消息队列添加任务，新任务都会加到消息队列的末尾，在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿去任务

##### 消息队列

> 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。

_随着浏览器复杂程度的急剧提升，w3c 不在使用宏队列的说法,目前在 chrome 浏览器中，至少包含了下面的队列:_

> 延时队列:用于存放 计时器 达到后的回调任务，优先级【中】

_计时器如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这种延迟是为了避免 JavaScript 的计时器嵌套过深，导致主线程被长时间占用而影响其他任务的执行。通过引入最小延迟时间和累积延迟时间的机制，可以更好地控制计时器的执行和事件循环的流畅性。_

> 交互队列（如点击事件）：用于存放用户操作后产生的事件处理任务，优先级【高】

> 微队列：用户存放需要最快执行的任务，如： Promise、MutationObserver 等 ，优先级【最高】

_每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列，再一次事件循环中，可以根据实际情况从不同的队列中取出执行任务_
