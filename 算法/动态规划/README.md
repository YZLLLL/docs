##### 什么是动态规划

动态规划是一种常用的算法思想，它通常用于解决具有重叠子问题和最优子结构性质的问题。动态规划的基本思想是将原问题分解成若干个子问题，先求解子问题，然后通过子问题的解来求解原问题。在求解子问题时，我们通常会使用一张表格来记录子问题的解，以便在求解原问题时能够快速地查找子问题的解。

动态规划通常分为两种类型：自顶向下的记忆化搜索和自底向上的动态规划。自顶向下的记忆化搜索通常使用递归的方式来求解子问题，而自底向上的动态规划则通常使用迭代的方式来求解子问题。在实际应用中，我们通常会根据问题的特点来选择合适的动态规划方法。

动态规划算法可以用于解决许多问题，如最长公共子序列、背包问题、最短路问题等。它已经成为计算机科学中的一个重要分支，被广泛应用于各种领域。

##### 解题思路

1. 确定问题：确定问题是否具有最优子结构和重叠子问题的特性。最优子结构意味着问题的最优解可以通过子问题的最优解来构建，而重叠子问题意味着问题的解可以通过重复计算相同的子问题来得到。

2. 定义状态：确定问题的状态，即问题需要求解的子问题的集合。状态应该能够描述问题的不同维度和变化过程，并且与问题的解相关。

3. **确定状态转移方程**（最关键！！）：根据问题的最优子结构性质，确定问题的状态转移方程。状态转移方程描述了问题的当前状态与下一个状态之间的关系。通过状态转移方程，可以将原问题分解为更小的子问题，并利用子问题的解来求解原问题。

4. 初始化边界条件：确定问题的边界条件，即最小规模的子问题的解。边界条件是问题的基础情况，通常是无需再分解的最小子问题。

5. 递推求解：根据状态转移方程，使用递推的方式求解子问题，并将子问题的解保存在一个表格或数组中。这样可以避免重复计算相同的子问题。

6. 求解原问题：根据子问题的解和状态转移方程，通过查表或数组，得到原问题的解。

##### 题目一： 打家劫舍

- 你是一个专业的小偷，计划偷窃沿街的房屋。
- 每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
- 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

分析：假设前 n 家能偷到的最大值为 S(n)，那么前 n + 1 家该怎么办呢？
如果偷，你就不能偷第 n 家, 那么你所获得的金额是 S(n - 1) + 第 n 家的金额；
不偷，那么你所获得的金额是 S(n)
故，前 n + 1 家最大金额为 Math.max( S(n - 1) + 第 n 家的金额, S(n) )，状态转移方程确定;

示例：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。

代码如下：

```js
function rob(nums) {
  // 初始化边界条件
  const dp = new Array(nums.length).fill(0);
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
  }
  return dp.at(-1);
}
const arr = [2, 7, 9, 3, 1];
console.log(rob(arr));
```

##### 题目二： 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

代码如下：

```js
function lengthOfLIS(nums) {
  // 初始化边界条件
  const dp = new Array(nums.length).fill(1);
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[j] + 1, dp[i]);
      }
    }
  }
  return Math.max(...dp);
}
console.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]));
```

##### 常见的动态规划问题的状态转移方程

以下几个常见的动态规划问题和它们对应的状态转移方程示例：

1. 斐波那契数列（Fibonacci Sequence）：

dp[i] = dp[i-1] + dp[i-2]，其中 dp[i] 表示第 i 个斐波那契数。

2. 爬楼梯问题（Climbing Stairs）：

dp[i] = dp[i-1] + dp[i-2]，其中 dp[i] 表示爬到第 i 级楼梯的方法数。

3. 背包问题（Knapsack Problem）：

dp[i][j] = max(dp[i-1][j], dp[i-1]j-weight[i] + value[i])，其中 dp[i][j] 表示在前 i 个物品中选择总重量不超过 j 的最大价值，weight[i] 表示第 i 个物品的重量，value[i] 表示第 i 个物品的价值。

4. 最长递增子序列（Longest Increasing Subsequence）：

dp[i] = max(dp[j] + 1, dp[i])，其中 dp[i] 表示以第 i 个元素结尾的最长递增子序列的长度，j 为 0 到 i-1 的索引，且 nums[i] > nums[j]。

5. 最大子数组和（Maximum Subarray Sum）：

dp[i] = max(nums[i], nums[i] + dp[i-1])，其中 dp[i] 表示以第 i 个元素结尾的最大子数组和。

6. 最长公共子序列（Longest Common Subsequence）：

如果 str1[i] 等于 str2[j]，则 dp[i][j] = dp[i-1][j-1] + 1；

否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])，其中 dp[i][j] 表示 str1 的前 i 个字符和 str2 的前 j 个字符的最长公共子序列的长度。

7. 编辑距离（Edit Distance）：

如果 word1[i] 等于 word2[j]，则 dp[i][j] = dp[i-1][j-1]；

否则，dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1，其中 dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作次数。

8.打家劫舍（House Robber）：

dp[i] = max(dp[i-1], dp[i-2] + nums[i])，其中 dp[i] 表示前 i 个房屋能够获得的最大金额，nums[i] 表示第 i 个房屋中的金额。

9. 最大正方形（Maximal Square）：

如果 matrix[i][j] 等于 1，则 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1；

否则，dp[i][j] = 0，其中 dp[i][j] 表示以 matrix[i][j] 为右下角的最大正方形的边长。
